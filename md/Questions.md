# [Главная](../README.md)

# Возникшие вопросы и уточнения:

## Первый вопрос:

### Вопрос:

Согласно условию:`Баннеры могут быть временно выключены. Если баннер выключен, то обычные пользователи не
должны его получать, при этом админы должны иметь к нему доступ.`

**Как разграничивается получение баннера админом и пользователем?**

### Ответ:

Так понимаю, что get запрос на `/user_banner` согласно API будет соответствовать получению баннера
пользователем, а get запрос на `/banner` будет соответствовать запросу админа. Следовательно для обработки запроса
на `/user_banner` будет необходимо учитывать состояние баннера, а для обработки запроса на `/banner` выводить админу
баннер в любом состоянии.

### Влияние на реализацию:

* Для запросов по методу get `/banner` возвращаются все баннеры в не зависимости от статуса.
* Для запросов по методу get `/user_banner` возвращается баннер только если он находится в активном состоянии, иначе
  возвращается код `404`.

## Второй вопрос:

### Вопрос:

Согласно условию:`Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую
актуальную информацию. В ином случае допускается передача информации, которая была актуальна 5 минут назад.`

**Каким образом обеспечивать передачу информации, которая была актуальна 5 минут назад?**

### Ответ:

Буду использовать кэширование запросов на получение пользователем баннера, с временем жизни кэша 5 минут.
В качестве хранилища буду использовать in-memory хранилище [Redis](https://developer.redis.com/).

Решение использовать [Redis](https://developer.redis.com/) позволяет в случае масштабирования сервиса позволит
нескольким экземплярам сервиса поддерживать общую информацию о кэшированных запросов, а также, в случае реализации
хранилища на базе map, позволяет пользоваться уже реализованной системой времени жизни записи
в [Redis](https://developer.redis.com/).

### Влияние на реализацию:

* Используется в качестве хранилища кэша in-memory хранилище [Redis](https://developer.redis.com/).
* Реализовано работа с хранилищем кэша в пакете `intrenal/caches`.
* Инстанс [Redis](https://developer.redis.com/) развёрнут в `docker compose`.


## Третий вопрос:

### Вопрос:

Согласно условию:`Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и
админский. Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные
действия могут выполняться только с помощью админского токена. `

**Кто выдаёт токены для работы?**

### Ответ:

Реализуемой мной сервис имплементирует часть логики большой системы и авторизация не входит в эту логику. Следовательно,
в системе в которую будет встраиваться сервис уже есть сервисы ответственные за авторизацию и выдачу токенов.

Тогда для простоты интеграции с потенциально существующим сервисом авторизации, в реализуемом сервисе имеет смысл
создать интерфейс, описывающий функционал проверки токенов. Таким образом при интеграции с общей системой, необходимо будет
реализовать этот интерфейс с обращением к существующему сервису авторизации.

Для проверки работоспособности сервиса получения баннеров имеет смысл сымитировать работу сервиса авторизации.
Для этого создадим два метода API, которые выдают без проверки пользовательский и админский токен.
А также реализуем интерфейс, описывающий функционал проверки токенов.
Раз мы эмулируем сервис авторизации, для упрощения хранения будем создавать токен с помощью uuid
и добавления приставки `user` или `admin` для пользовательского и админского токена, соответственно.
Такой подход позволит не хранить токены и быстро проверить их принадлежность.

### Влияние на реализацию:

* Добавлен пакет `external` добавлена реализация сервиса эмулирующего сервис авторизации и выдачи токенов.
* Добавлены get методы `/token/user` и `/token/admin`, выдающие пользовательский и админский токен соответственно.
* Создан пакет `/internal/token` описывающий интерфейс, который используется сервисом для проверки токенов.
* Реализованы мидделвары проверяющие наличие токена в заголовках запроса и наличие прав у токена.

## Четвёртый вопрос:

### Вопрос:

Согласно условию:`Необходимо реализовать сервис, который позволяет показывать пользователям баннеры,
в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.`

**Как учитывать пользователей при управлении тэгами и из чего состоят тэги и фичи?**

### Ответ:

Реализуемый мной сервис является частью уже существующей системы. Значит, логично предположить, что в системе уже
существуют группы пользователей и фичи. Следовательно, для реализации сервиса в отдельности имеет смысл рассматривать
тэги и фичи как уникальные идентификаторы и хранить их.

А при интеграции сервиса с существующей системой добавить ограничения внешнего ключа на эти идентификаторы,
таким образом связав баннеры с существующими сущностями фич и тэгов.

### Влияние на реализацию:

* Создана таблица `features_tags_banner` описывающая связь идентификаторов баннера, фичи и тэга группы пользователей.

## Пятый вопрос:

### Вопрос:

Согласно API для get метода `/banner` offset и limit могут быть не представлены.

**В случае если они не заданы каким образом выбирать баннеры?**

### Ответ:

Следует ожидать, что баннеров может быть много. Cледовательно, вычитывание всего списка баннеров может
оказать слишком долгим процессом. Поэтому имеет смысл установить в качестве значений по умолчанию для параметра `limit`,
например, *100* записей. А для параметра `offset` -- *0*.

### Влияние на реализацию:

* Добавлены значения по умолчанию для параметров `limit` и `оффсет`.

## Шестой вопрос:

### Вопрос:

Согласно условию `Фича и тег однозначно определяют баннер`.

**Что делать, если при создании или обновлении баннера будет передан уже используемая пара тэг + фича?**

### Ответ:

Для решения такого конфликта имеет смысл добавить в API для методов создания и обновления баннеров ответ
с кодом `409`, который будет означать, что баннер с переданной парой фича+тэг уже существует.

### Влияние на реализацию:

* Добавлены в метод post `/banner` обработка конфликат пары фича+тэг и код возврата `409`.
* Добавлены в метод patch `/banner/{id}` обработка конфликат пары фича+тэг и код возврата `409`.

## Седьмой вопрос:

### Вопрос:

Согласно API для get метода `/banner` в строке запроса передаются параметры метода.

**Что делать если вместо числа в численные параметры передали другой тип данных?**

### Ответ:

Для решения проблем с неверным типом в запросе имеет смысл добавить в API для этого метода ответ с кодом 400,
который будет означать что в полях параметров запроса есть ошибка.

### Влияние на реализацию:

* Добавлены в метод get `/banner` обработка ошибки неправильного типа параметров запроса и код возврата `400`.

## Восьмой вопрос:

### Вопрос:

Согласно условию: `Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера
в связи с найденной ошибкой в логике, тексте и т.д. Измените API таким образом, чтобы можно было просмотреть
существующие версии баннера и выбрать подходящую версию`.

**Как влияет добавление версии на кэширование?**

### Ответ:

Необходимо учитывать версию, в качестве определения уникального запроса для кэширования, т.к. иначе поведение метода
становится не очевидным, из-за того что при изменение версии в запросе результат не меняется, что может сбить с толку пользователя.

### Влияние на реализацию:

* Версия добавлена как ещё один параметр определяющий запись в кэше.

## Девятый вопрос:

### Вопрос:

Согласно условию `Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера в связи с
найденной ошибкой в логике, тексте и т.д.  Измените API таким образом, чтобы можно было просмотреть существующие
версии баннера и выбрать подходящую версию.`

**Что считать новой версией баннеры?**

### Ответ:

У баннера мы можем изменять контент, его состояние, тэги групп пользователей и фичи.
* Состояние показывает доступность баннера пользователю, значит его изменение не может являться новой версией банера.
* По условию каждая пара тэга и фичи определяют уникальный баннер, значит изменение какого-либо параметра можно воспринимать,
  как переопределения банера в целом, а не создания его версии.
* Остаётся изменение контента.

Будем считать, что при изменение контента баннера у него появляется новая версия. Для поддержки такой функциональности
была расширена схема базы данных таблицей хранящей контент с версией для каждого баннера. В качестве версии достаточно использовать
порядковой номер изменения контента (отдельное поле, не идентификатор этой таблицы).

### Влияние на реализацию:

* Хранение контента баннера вынесено в отельную таблицу, которая хранит версию, контент и дату создания версии.
* Добавлен триггер, который при добавлении версии рассчитывает номер этой версии и удаляет слишком старую версию, чтобы
  оставались только последние 3.
